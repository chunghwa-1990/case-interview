## Redis

### 什么是缓存雪崩?

比如说一个系统，一个 mysql 的最大并发请求是 1000 个 qps，在加上 redis 缓存的前提下，可以支持到 5000 个 qps，但实际在某阶段产生了 6000 个 qps，这时候 redis 因为性能或者其他一些原因发生了宕机。缓存宕机之后，导致这 6000 个请求同时打到了数据库，这时候数据库必然扛不住，数据库会报一下警，然后就挂了。然后重启 redis 和 mysql，紧接着又被新的流量给打死了。

<code>解决方法：</code>

**事前：** 设置 redis 高可用、主从哨兵、集群模式，避免全面崩盘
**事中：** 开启 ehcache 缓存，微服务客户端设置限流&降级/熔断机制，避免 mysql 直接被打死
**事后：** 开启 redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据

用户发送一个请求，系统 A 收到请求后，先查本地 ehcache 缓存，如果没查到再查 Redis。如果 ehcache 和 Redis 都没有，再查数据库，将数据库中的结果，写入 ehcache 和 Redis 中。

限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空值。

<code>好处：</code>

- 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。
- 只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。
- 只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来了。

### 什么是缓存穿透？

比如刚才说的那个 6000 个 qps，假设都是黑客发出来的恶意请求，黑客也不知道缓存和数据库的真实key值，例如 -1 等等这些非法值，那么这些请求会查询 redis 缓存，redis 中不存在该 key 的 value，就会直接打到数据库上，这时候数据库同样会挂掉。

<code>解决方法：</code>

假如 redis 中不存在该 key 值，数据库同样没查到，就直接写一个空值到缓存里，比如 set -1 UNKNOWN，然后设置一个过期时间，这样的话，下次有相同 key 来访问的话，在缓存失效之前都可以访问。

假如每次请求都是不同的 key 值，就在缓存之前增加布隆过滤器，将数据库中所有的可能数据哈希映射到布隆过滤器中，然后对每个请求进行判断：

- 请求数据的 key 不存在于布隆过滤器中，可以确定数据就一定不会存在于数据库中，系统可以立即返回不存在。
- 请求数据的 key 存在于布隆过滤器中，则继续再向缓存中查询。

使用布隆过滤器能够对访问的请求起到了一定的初筛作用，避免了因数据不存在引起的查询压力。

## 缓存击穿

缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

不同场景下的解决方式可如下：

- 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
- 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 Redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
- 若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。